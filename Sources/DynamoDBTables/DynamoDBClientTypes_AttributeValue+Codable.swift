// Code generated by smithy-swift-codegen. DO NOT EDIT!
// swiftlint:disable identifier_name cyclomatic_complexity function_body_length

import AWSDynamoDB
import Foundation

public struct Key: CodingKey {
    public let stringValue: String
    public init(stringValue: String) {
        self.stringValue = stringValue
        self.intValue = nil
    }

    public init(_ stringValue: String) {
        self.stringValue = stringValue
        self.intValue = nil
    }

    public let intValue: Int?
    public init?(intValue _: Int) {
        nil
    }
}

extension DynamoDBClientTypes.AttributeValue: @retroactive Swift.Decodable, @retroactive Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case b = "B"
        case bool = "BOOL"
        case bs = "BS"
        case l = "L"
        case m = "M"
        case n = "N"
        case ns = "NS"
        case null = "NULL"
        case s = "S"
        case ss = "SS"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case let .b(b):
            try container.encode(b.base64EncodedString(), forKey: .b)
        case let .bool(bool):
            try container.encode(bool, forKey: .bool)
        case let .bs(bs):
            var bsContainer = container.nestedUnkeyedContainer(forKey: .bs)
            for binaryattributevalue0 in bs {
                try bsContainer.encode(binaryattributevalue0.base64EncodedString())
            }
        case let .l(l):
            var lContainer = container.nestedUnkeyedContainer(forKey: .l)
            for attributevalue0 in l {
                try lContainer.encode(attributevalue0)
            }
        case let .m(m):
            var mContainer = container.nestedContainer(keyedBy: Key.self, forKey: .m)
            for (dictKey0, mapAttributeValue0) in m {
                try mContainer.encode(mapAttributeValue0, forKey: Key(stringValue: dictKey0))
            }
        case let .n(n):
            try container.encode(n, forKey: .n)
        case let .ns(ns):
            var nsContainer = container.nestedUnkeyedContainer(forKey: .ns)
            for numberattributevalue0 in ns {
                try nsContainer.encode(numberattributevalue0)
            }
        case let .null(null):
            try container.encode(null, forKey: .null)
        case let .s(s):
            try container.encode(s, forKey: .s)
        case let .ss(ss):
            var ssContainer = container.nestedUnkeyedContainer(forKey: .ss)
            for stringattributevalue0 in ss {
                try ssContainer.encode(stringattributevalue0)
            }
        case let .sdkUnknown(sdkUnknown):
            try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s)
        if let s = sDecoded {
            self = .s(s)
            return
        }
        let nDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .n)
        if let n = nDecoded {
            self = .n(n)
            return
        }
        let bDecoded = try values.decodeIfPresent(Foundation.Data.self, forKey: .b)
        if let b = bDecoded {
            self = .b(b)
            return
        }
        let ssContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .ss)
        var ssDecoded0: [Swift.String]? = nil
        if let ssContainer {
            ssDecoded0 = [Swift.String]()
            for string0 in ssContainer {
                if let string0 {
                    ssDecoded0?.append(string0)
                }
            }
        }
        if let ss = ssDecoded0 {
            self = .ss(ss)
            return
        }
        let nsContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .ns)
        var nsDecoded0: [Swift.String]? = nil
        if let nsContainer {
            nsDecoded0 = [Swift.String]()
            for string0 in nsContainer {
                if let string0 {
                    nsDecoded0?.append(string0)
                }
            }
        }
        if let ns = nsDecoded0 {
            self = .ns(ns)
            return
        }
        let bsContainer = try values.decodeIfPresent([Foundation.Data?].self, forKey: .bs)
        var bsDecoded0: [Foundation.Data]? = nil
        if let bsContainer {
            bsDecoded0 = [Foundation.Data]()
            for blob0 in bsContainer {
                if let blob0 {
                    bsDecoded0?.append(blob0)
                }
            }
        }
        if let bs = bsDecoded0 {
            self = .bs(bs)
            return
        }
        let mContainer = try values.decodeIfPresent(
            [Swift.String: DynamoDBClientTypes.AttributeValue?].self,
            forKey: .m
        )
        var mDecoded0: [Swift.String: DynamoDBClientTypes.AttributeValue]? = nil
        if let mContainer {
            mDecoded0 = [Swift.String: DynamoDBClientTypes.AttributeValue]()
            for (key0, attributevalue0) in mContainer {
                if let attributevalue0 {
                    mDecoded0?[key0] = attributevalue0
                }
            }
        }
        if let m = mDecoded0 {
            self = .m(m)
            return
        }
        let lContainer = try values.decodeIfPresent([DynamoDBClientTypes.AttributeValue?].self, forKey: .l)
        var lDecoded0: [DynamoDBClientTypes.AttributeValue]? = nil
        if let lContainer {
            lDecoded0 = [DynamoDBClientTypes.AttributeValue]()
            for union0 in lContainer {
                if let union0 {
                    lDecoded0?.append(union0)
                }
            }
        }
        if let l = lDecoded0 {
            self = .l(l)
            return
        }
        let nullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .null)
        if let null = nullDecoded {
            self = .null(null)
            return
        }
        let boolDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .bool)
        if let bool = boolDecoded {
            self = .bool(bool)
            return
        }
        self = .sdkUnknown("")
    }
}
